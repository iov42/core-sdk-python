"""Basic implementation for platform cryptography support."""
import base64
from typing import Any
from typing import Type
from typing import TypeVar
from typing import Union

import cryptography.exceptions
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.asymmetric import padding
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePrivateKey
from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey


# TODO: make exception handling as it should be
class InvalidSignature(Exception):
    """Signature verification failed."""

    pass


_P = TypeVar("_P", bound="CryptoProtocolInterface")


class PublicKey:
    """A public key."""

    def __init__(self, protcol_cls: Type[_P], key: Any) -> None:
        """Create public key for given protocol."""
        self.protocol = protcol_cls
        self.key = key

    def verify_signature(self, signature: str, data: str) -> None:
        """Verify one block of data was signed by the private key associated with this public key.

        Args:
            signature: Signature to verify as Base64 encoded string.
            data: The data for which the signature

        Raises:
            InvalidSignature: if the verification failed.
        """
        # add extra padding (will be ignored if too much, but throws an error if not present)
        signature_bytes = _str_decode_bytes(signature)
        data_bytes = data.encode()

        try:
            self.protocol.verify_signature(self.key, signature_bytes, data_bytes)
        except cryptography.exceptions.InvalidSignature:
            raise InvalidSignature()

    def dump(self) -> str:
        """Serialize public key to string representation used by the iov42 platform."""
        key_bytes = self.protocol.dump_public_key(self.key)
        return _str_encode_bytes(key_bytes)


def _str_encode_bytes(data: bytes) -> str:
    """Encode bytes into string."""
    return base64.urlsafe_b64encode(data).decode().rstrip("=")


def _str_decode_bytes(data: str) -> bytes:
    """Decode string into bytes."""
    # add extra padding (will be ignored if too much, but throws an error if not present)
    return base64.urlsafe_b64decode(data + "==")


class PrivateKey:
    """Interface for working with private keys."""

    def __init__(self, protcol_cls: Type[_P], key: Any):
        """Create private key with given protocol."""
        self.protocol = protcol_cls
        self.key = key

    def public_key(self) -> PublicKey:
        """Returns the public key associated to private key."""
        return self.protocol.public_key(self.key)

    def sign(self, data: str) -> str:
        """Sign one block of data which can be verified later by other using the public key."""
        data_bytes = data.encode()
        signature_bytes = self.protocol.sign(self.key, data_bytes)
        return _str_encode_bytes(signature_bytes)

    def dump(self) -> str:
        """Serialize private key to string representation (base64)."""
        key_bytes = self.protocol.dump_private_key(self.key)
        return _str_encode_bytes(key_bytes)


# TODO: can we provide type information for the keys the crypto backend is providing?
class CryptoProtocolInterface:
    """Abstract base class which wraps the used crypto library."""

    name = "not supported"

    # TODO: this is in reality an implemenation of the Cryptography library. We
    # have to seperated this with a generic interface (ABC).

    @classmethod
    def generate_private_key(cls) -> PrivateKey:
        """Create an key pair."""

    @classmethod
    def public_key(cls, private_key: Any) -> PublicKey:
        """Returns public key generated by the given private key."""
        return PublicKey(cls, private_key.public_key())

    @staticmethod
    def sign(private_key: Any, data: bytes) -> bytes:
        """Sign one block of data which can be verified later by other using the public key.

        Args:
            private_key: The private key with which the data is signed.
            data: The message data to sign.

        Return:
            Signature: signature
        """

    @staticmethod
    def verify_signature(public_key: Any, signature: bytes, data: bytes) -> None:
        """Verifies the supplied signature.

        Args:
            public_key: public key with which the verification is done.
            signature: The signature to verify.
            data: The message that was signed.

        Raises:
            InvalidSignature if signature is not valid.
        """

    @staticmethod
    def dump_private_key(private_key: Any) -> bytes:
        """Serialize public key to bytes."""
        key_bytes = private_key.private_bytes(
            serialization.Encoding.DER,
            serialization.PrivateFormat.PKCS8,
            serialization.NoEncryption(),
        )
        return key_bytes  # type: ignore[no-any-return]

    @staticmethod
    def dump_public_key(public_key: Any) -> bytes:
        """Serialize public key to bytes."""
        key_bytes = public_key.public_bytes(
            serialization.Encoding.DER, serialization.PublicFormat.SubjectPublicKeyInfo
        )
        return key_bytes  # type: ignore[no-any-return]


class CryptographyRSA(CryptoProtocolInterface):
    """Wraps used crypto library implemenation."""

    name = "SHA256WithRSA"

    @classmethod
    def generate_private_key(cls) -> PrivateKey:
        """Create an RSA key pair."""
        # mypy ignore: Missing positional argument "backend" in call to "generate_private_key"
        return PrivateKey(
            cls,
            rsa.generate_private_key(public_exponent=65537, key_size=2048),  # type: ignore[call-arg]
        )

    @staticmethod
    def sign(private_key: RSAPrivateKey, data: bytes) -> bytes:
        """Sign one block of data which can be verified later by other using the public key.

        Args:
            private_key: The private key with which the data is signed.
            data: The message data to sign.

        Returns:
            Signature
        """
        return private_key.sign(data, padding.PKCS1v15(), hashes.SHA256())

    @staticmethod
    def verify_signature(
        public_key: RSAPublicKey, signature: bytes, data: bytes
    ) -> None:
        """Verfies the supplied signature.

        Args:
            public_key: RSA public key with which the verification is done.
            signature: The signature to verify.
            data: The message that was signed.

        Raises:
            InvalidSignature if signature is not valid.
        """
        public_key.verify(
            signature,
            data,
            padding.PKCS1v15(),
            hashes.SHA256(),
        )


class CryptographyECDSA(CryptoProtocolInterface):
    """Wraps used backend implemenation."""

    name = "SHA256WithECDSA"

    @classmethod
    def generate_private_key(cls) -> PrivateKey:
        """Create an ECDSA key pair."""
        # mypy ignore: Too few arguments for "generate_private_key"
        # mypy ignore: Argument 1 to "generate_private_key" has incompatible
        #              type "Type[SECP256K1]"; expected "EllipticCurve"
        return PrivateKey(cls, ec.generate_private_key(ec.SECP256K1))  # type: ignore[call-arg,arg-type]

    @staticmethod
    def sign(private_key: EllipticCurvePrivateKey, data: bytes) -> bytes:
        """Sign one block of data which can be verified later by other using the public key."""
        return bytes(private_key.sign(data, ec.ECDSA(hashes.SHA256())))

    @staticmethod
    def verify_signature(
        public_key: EllipticCurvePublicKey, signature: bytes, data: bytes
    ) -> None:
        """Verfies the supplied signature.

        Args:
            public_key: ECDSA public key with which the verification is done.
            signature: The signature to verify.
            data: The message that was signed.

        Raises:
            InvalidSignature if signature is not valid.
        """
        public_key.verify(signature, data, ec.ECDSA(hashes.SHA256()))


# TODO: when introducing the CryptoProtocol interface, replace this code a
# protocol registry.
class CryptoProtocol:
    """List of all supported encryption protocols."""

    SHA256WithRSA = CryptoProtocolInterface
    SHA256WithECDSA = CryptoProtocolInterface


_protocol_registry = {}


def _register_protocol(protocol: Type[CryptoProtocolInterface]) -> None:
    _protocol_registry[protocol.name] = protocol
    setattr(CryptoProtocol, protocol.name, protocol)


_register_protocol(CryptographyRSA)
_register_protocol(CryptographyECDSA)


def generate_private_key(
    crypto_protocol: Union[str, Type[CryptoProtocolInterface]]
) -> PrivateKey:
    """Generate private key."""
    try:
        protocol = (
            _protocol_registry[crypto_protocol]
            if isinstance(crypto_protocol, str)
            else crypto_protocol
        )
        return protocol.generate_private_key()
    except (KeyError, AttributeError):
        raise ValueError(f"unknown crypto protocol '{crypto_protocol}'")


def load_private_key(private_key: str) -> PrivateKey:
    """Deserialize a private key iov42 encoded data to a public key."""
    # TODO CryptoProtocol, ... this still feels wrong.
    key_bytes = _str_decode_bytes(private_key)
    key = serialization.load_der_private_key(key_bytes, password=None, backend=None)
    cls = (
        CryptoProtocol.SHA256WithRSA
        if isinstance(key, RSAPrivateKey)
        else CryptoProtocol.SHA256WithECDSA
    )
    return PrivateKey(cls, key)


def load_public_key(public_key: str) -> PublicKey:
    """Deserialize a public key iov42 encoded data to a public key."""
    key_bytes = _str_decode_bytes(public_key)
    key = serialization.load_der_public_key(key_bytes, backend=None)
    cls = (
        CryptoProtocol.SHA256WithRSA
        if isinstance(key, RSAPublicKey)
        else CryptoProtocol.SHA256WithECDSA
    )
    return PublicKey(cls, key)
